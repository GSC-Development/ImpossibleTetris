<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Impossible Tetris</title>
<style>
    /* ----------  LAYOUT & VISUALS ---------- */
    * {
        -webkit-tap-highlight-color: transparent;
        box-sizing: border-box;
    }
    
    html, body {
        overscroll-behavior: none;
        position: fixed;
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
    body {
        background:#121212;
        color:#fff;
        font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        display:flex;
        justify-content:center;
        overflow-x:hidden;
        touch-action:manipulation;
        padding: 0;
    }
    
    .game-container {
        display:flex;
        flex-direction:column;
        align-items:center;
        max-width:800px;
        width: 100%;
        height: 100%;
        margin:0 auto;
        padding: 10px 5px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }
    
    .title {
        font-size:28px;
        font-weight:bold;
        margin:10px 0;
        color:#ff2d55;
        text-shadow:0 0 10px rgba(255,45,85,.5);
        text-align:center;
    }
    
    .game-area {
        display:flex;
        flex-direction: column;
        align-items:center;
        margin-bottom:10px;
        width: 100%;
    }
    
    #tetris-board {
        width:min(300px, 85vw);
        height:min(600px, 60vh);
        background:#1e1e1e;
        border:3px solid #333;
        position:relative;
        touch-action:none;
        -webkit-user-select:none;
        user-select:none;
        overflow:hidden;
        margin: 0 auto 15px auto;
    }
    
    .info-panel {
        width:min(300px, 85vw);
        display:flex;
        flex-wrap:wrap;
        justify-content:space-between;
        gap:10px;
    }
    
    .info-box {
        background:#252525;
        border:2px solid #444;
        border-radius:8px;
        padding:10px;
        flex: 1 0 calc(50% - 5px);
        min-width: 120px;
    }
    
    .panel-title {
        margin:0 0 10px;
        color:#5ac8fa;
        font-weight:bold;
        font-size:16px;
        text-align:center;
    }
    
    #next-piece {
        width:80px;
        height:80px;
        margin:0 auto;
        background:#1e1e1e;
        position:relative;
    }
    
    #score-value, #level-value {
        font-size:22px;
        text-align:center;
        font-weight:bold;
        color:#ff9500;
    }
    
    .controls {
        display:none; /* Hide keyboard controls on mobile */
    }
    
    #start-button {
        background:#ff2d55;
        color:#fff;
        border:none;
        padding:15px 30px;
        font-size:18px;
        border-radius:8px;
        cursor:pointer;
        margin:15px 0;
        transition:background .3s;
        -webkit-appearance: none;
    }
    
    #start-button:hover, #start-button:active {
        background:#ff0040;
    }
    
    .tetromino, .locked-block {
        position:absolute;
        box-sizing:border-box;
        border:1px solid rgba(255,255,255,.2);
    }
    
    /* Game Over Popup Styles */
    .game-over {
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%, -50%);
        width:85%;
        max-width:240px;
        background:rgba(0,0,0,0.9);
        border:3px solid #444;
        border-radius:10px;
        display:flex;
        flex-direction:column;
        justify-content:center;
        align-items:center;
        z-index:10;
        display:none;
        text-align:center;
        padding:30px 15px;
        box-shadow:0 0 20px rgba(0,0,0,0.7);
    }
    
    .game-over-text {
        font-size:24px;
        color:#ff2d55;
        margin-bottom:15px;
        font-weight:bold;
        width:100%;
        text-align:center;
    }
    
    .final-score-message {
        font-size:16px;
        margin-bottom:25px;
        color:#eee;
        width:100%;
        text-align:center;
    }
    
    #restart-button {
        background:#ff2d55;
        color:#fff;
        border:none;
        padding:12px 25px;
        font-size:16px;
        border-radius:8px;
        cursor:pointer;
        transition:background 0.3s;
        -webkit-appearance: none;
    }
    
    #restart-button:hover, #restart-button:active {
        background:#ff0040;
    }
    
    .audio-controls {
        margin: 10px 0;
        display: flex;
        justify-content: center;
    }
    
    .audio-toggle {
        background: #252525;
        border: none;
        color: #fff;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-bottom: 5px;
        -webkit-appearance: none;
    }
    
    .audio-toggle:hover, .audio-toggle:active {
        background: #333;
    }
    
    /* Mobile Controls */
    .mobile-controls {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin: 10px 0;
        width: 100%;
        max-width: 320px;
    }
    
    .mobile-controls-row {
        display: flex;
        justify-content: space-between;
        width: 100%;
        gap: 15px;
    }
    
    .mobile-btn {
        width: 70px;
        height: 70px;
        background: rgba(255,255,255,0.15);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 28px;
        color: #fff;
        border: none;
        outline: none;
        touch-action: manipulation;
        -webkit-appearance: none;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .mobile-btn:active {
        background: rgba(255,255,255,0.3);
        transform: scale(0.95);
    }
    
    .mobile-btn.drop-btn {
        width: 100%;
        border-radius: 35px;
        height: 60px;
        margin-top: 10px;
    }
    
    /* Modern Creator Tag Styles */
    .creator-tag {
        position: relative;
        margin: 15px 0;
        width: 100%;
        text-align: center;
        padding: 10px 0;
        overflow: hidden;
    }
    
    .creator-name {
        position: relative;
        display: inline-block;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-weight: 800;
        font-size: 16px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: transparent;
        background: linear-gradient(90deg, #ff2d55, #5ac8fa, #ffcc00, #34c759);
        background-size: 400% 400%;
        -webkit-background-clip: text;
        background-clip: text;
        animation: gradient 8s ease infinite;
        padding: 5px 15px;
        border-radius: 20px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes gradient {
        0% { background-position: 0% 50% }
        50% { background-position: 100% 50% }
        100% { background-position: 0% 50% }
    }
    
    /* ----------  COLORS ---------- */
    .color-1{background:#ff2d55}.color-2{background:#5ac8fa}.color-3{background:#ffcc00}
    .color-4{background:#34c759}.color-5{background:#af52de}.color-6{background:#ff9500}.color-7{background:#007aff}
    
    /* ----------  DESKTOP OVERRIDES ---------- */
    @media (min-width:700px) {
        .title {
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        .game-area {
            flex-direction: row;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }
        
        #tetris-board {
            margin: 0;
            width: 300px;
            height: 600px;
        }
        
        .info-panel {
            width: 180px;
            flex-direction: column;
            flex-wrap: nowrap;
        }
        
        .info-box {
            width: 100%;
            flex: none;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(3,1fr);
            gap: 5px;
            text-align: center;
        }
        
        .key {
            background: #333;
            padding: 8px 0;
            border-radius: 4px;
            margin-bottom: 5px;
            grid-column: 2;
        }
        
        .key-left{grid-column: 1}
        .key-right{grid-column: 3}
        .key-down{grid-column: 2}
        .key-space{grid-column: 1/ span 3; margin-top: 5px}
        
        .control-label {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
            grid-column: 1/ span 3;
        }
        
        .mobile-controls {
            display: none;
        }
        
        .creator-name {
            font-size: 18px;
            letter-spacing: 2px;
        }
    }
</style>
</head>
<body>
<div class="game-container">
    <div class="title">IMPOSSIBLE TETRIS</div>
    <div class="game-area">
        <div id="tetris-board">
            <!-- Game Over screen will be injected by initGame -->
        </div>
        <div class="info-panel">
            <div class="info-box">
                <h3 class="panel-title">NEXT</h3>
                <div id="next-piece"></div>
            </div>
            <div class="info-box">
                <h3 class="panel-title">SCORE</h3>
                <div id="score-value">0</div>
            </div>
            <div class="info-box">
                <h3 class="panel-title">LEVEL</h3>
                <div id="level-value">1</div>
            </div>
            <div class="info-box controls-box">
                <h3 class="panel-title">CONTROLS</h3>
                <div class="controls">
                    <div class="key key-left">←</div>
                    <div class="key key-up">↑</div>
                    <div class="key key-right">→</div>
                    <div class="control-label">MOVE / ROTATE</div>
                    <div class="key key-down">↓</div>
                    <div class="control-label">SOFT DROP</div>
                    <div class="key key-space">SPACE</div>
                    <div class="control-label">HARD DROP</div>
                </div>
            </div>
        </div>
    </div>
    <div class="audio-controls">
        <button id="toggle-music" class="audio-toggle">🔊 Music</button>
    </div>
    <div class="mobile-controls">
        <div class="mobile-controls-row">
            <button class="mobile-btn" id="mobile-left">←</button>
            <button class="mobile-btn" id="mobile-rotate">↑</button>
            <button class="mobile-btn" id="mobile-right">→</button>
        </div>
        <div class="mobile-controls-row">
            <button class="mobile-btn" id="mobile-down">↓</button>
            <button class="mobile-btn drop-btn" id="mobile-drop">DROP</button>
        </div>
    </div>
    <button id="start-button">START GAME</button>
    <div class="creator-tag">
        <span class="creator-name">BUILT BY SORRYCOOL 2025</span>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    /* ---------- ELEMENTS ---------- */
    const board          = document.getElementById('tetris-board');
    const nextPieceDisp  = document.getElementById('next-piece');
    const scoreDisp      = document.getElementById('score-value');
    const levelDisp      = document.getElementById('level-value');
    const startButton    = document.getElementById('start-button');
    const musicToggle    = document.getElementById('toggle-music');
    
    /* ---------- AUDIO SYSTEM ---------- */
    // Create Web Audio API context
    let audioContext;
    let mainGainNode;
    let isAudioInitialized = false;
    let isMusicPlaying = false;
    let currentTrack = null;
    let notesPlaying = [];
    
    // Initialize audio system
    function initAudio() {
        if (isAudioInitialized) return;
        
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            mainGainNode = audioContext.createGain();
            mainGainNode.gain.value = 0.5; // Fixed volume level without slider
            mainGainNode.connect(audioContext.destination);
            isAudioInitialized = true;
        } catch (e) {
            console.error("Web Audio API not supported:", e);
        }
    }
    
    // Track 1: Main theme - expanded 8-bit melody with double the length
    const mainTheme = {
        notes: [
            // First part
            { pitch: 'C4', duration: 0.25 },
            { pitch: 'E4', duration: 0.25 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'C5', duration: 0.25 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'E4', duration: 0.25 },
            { pitch: 'A4', duration: 0.5 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'F4', duration: 0.25 },
            { pitch: 'E4', duration: 0.25 },
            { pitch: 'D4', duration: 0.25 },
            { pitch: 'E4', duration: 0.5 },
            { pitch: 'G4', duration: 0.5 },
            // Second part - new section
            { pitch: 'A4', duration: 0.25 },
            { pitch: 'C5', duration: 0.25 },
            { pitch: 'B4', duration: 0.25 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'A4', duration: 0.5 },
            { pitch: 'E4', duration: 0.5 },
            // Third part - new variation
            { pitch: 'D4', duration: 0.25 },
            { pitch: 'F4', duration: 0.25 },
            { pitch: 'A4', duration: 0.25 },
            { pitch: 'D5', duration: 0.25 },
            { pitch: 'A4', duration: 0.25 },
            { pitch: 'F4', duration: 0.25 },
            { pitch: 'G4', duration: 0.5 },
            // Fourth part - final section
            { pitch: 'E4', duration: 0.25 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'C5', duration: 0.25 },
            { pitch: 'E5', duration: 0.25 },
            { pitch: 'C5', duration: 0.25 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'C5', duration: 0.5 },
            { pitch: 'B4', duration: 0.25 },
            { pitch: 'A4', duration: 0.25 },
            { pitch: 'G4', duration: 0.25 },
            { pitch: 'F4', duration: 0.25 },
            { pitch: 'E4', duration: 0.5 },
            { pitch: 'C4', duration: 0.5 }
        ],
        tempo: 140
    };
    
    // Convert note name to frequency
    function noteToFrequency(note) {
        const notes = {'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11};
        const noteName = note.slice(0, -1);
        const octave = parseInt(note.slice(-1));
        
        // A4 is 440Hz
        const semitoneFromA4 = (octave - 4) * 12 + notes[noteName] - notes['A'];
        return 440 * Math.pow(2, semitoneFromA4 / 12);
    }
    
    // Create 8-bit style oscillator
    function createOscillator(freq, type = 'square') {
        if (!isAudioInitialized) return null;
        
        const osc = audioContext.createOscillator();
        osc.type = type;
        osc.frequency.value = freq;
        
        // Add slight detune for more 8-bit feel
        osc.detune.value = Math.random() * 5 - 2.5;
        
        return osc;
    }
    
    // Play a single note with 8-bit style
    function playNote(note, duration, when = 0) {
        if (!isAudioInitialized) return;
        
        const freq = noteToFrequency(note);
        
        // Create main oscillator
        const osc = createOscillator(freq);
        if (!osc) return;
        
        // Create envelope
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 0;
        
        // Connect
        osc.connect(gainNode);
        gainNode.connect(mainGainNode);
        
        // Set envelope
        const now = audioContext.currentTime;
        const startTime = now + when;
        const releaseTime = startTime + duration * 0.8;
        
        // Attack
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.02);
        
        // Release
        gainNode.gain.setValueAtTime(0.3, releaseTime);
        gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
        
        // Start and stop
        osc.start(startTime);
        osc.stop(startTime + duration + 0.05);
        
        // Track oscillators to stop them if needed
        notesPlaying.push({osc, gainNode, stopTime: startTime + duration + 0.05});
        
        // Clean up finished notes
        setTimeout(() => {
            notesPlaying = notesPlaying.filter(note => note.stopTime > audioContext.currentTime);
        }, (when + duration + 0.1) * 1000);
    }
    
    // Play a melody (sequence of notes)
    function playMelody(melody, loop = true) {
        if (!isAudioInitialized || !melody || !melody.notes || melody.notes.length === 0) return;
        
        const tempo = melody.tempo || 120;
        const secondsPerBeat = 60 / tempo;
        
        let totalDuration = 0;
        
        // Play each note with timing
        melody.notes.forEach(note => {
            playNote(note.pitch, note.duration * secondsPerBeat, totalDuration);
            totalDuration += note.duration * secondsPerBeat;
        });
        
        // Loop if needed
        if (loop) {
            currentTrack = setTimeout(() => {
                playMelody(melody, loop);
            }, totalDuration * 1000);
        }
    }
    
    // Stop all currently playing music
    function stopMusic() {
        // Clear any pending melody loops
        if (currentTrack) {
            clearTimeout(currentTrack);
            currentTrack = null;
        }
        
        // Stop any playing notes
        if (isAudioInitialized) {
            notesPlaying.forEach(note => {
                note.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                note.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
                note.osc.stop(audioContext.currentTime + 0.2);
            });
            notesPlaying = [];
        }
        
        isMusicPlaying = false;
    }
    
    // Toggle music on/off
    function toggleMusic() {
        if (!isAudioInitialized) {
            initAudio();
        }
        
        if (isMusicPlaying) {
            stopMusic();
            if (musicToggle) musicToggle.textContent = "🔇 Music";
        } else {
            playMelody(mainTheme, true);
            isMusicPlaying = true;
            if (musicToggle) musicToggle.textContent = "🔊 Music";
        }
    }
    
    // Set up audio controls
    if (musicToggle) {
        musicToggle.addEventListener('click', toggleMusic);
    }
    
    // Special sound effects
    function playLineClearEffect() {
        if (!isAudioInitialized) return;
        
        const osc = createOscillator(440);
        const gainNode = audioContext.createGain();
        
        osc.connect(gainNode);
        gainNode.connect(mainGainNode);
        
        const now = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0.3, now);
        
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.linearRampToValueAtTime(220, now + 0.2);
        
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
        
        osc.start(now);
        osc.stop(now + 0.3);
    }
    
    function playGameOverEffect() {
        if (!isAudioInitialized) return;
        
        const osc = createOscillator(440);
        const gainNode = audioContext.createGain();
        
        osc.connect(gainNode);
        gainNode.connect(mainGainNode);
        
        const now = audioContext.currentTime;
        
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.linearRampToValueAtTime(110, now + 1);
        
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 1);
        
        osc.start(now);
        osc.stop(now + 1.1);
    }
    
    let restartButton;
    let gameOverScreen;

    /* ---------- CONSTANTS ---------- */
    const ROWS=20,COLS=10;
    let BLOCK_SIZE;
    const UPDATE_MS  = 1000;

    /* ---------- STATE ---------- */
    let grid, currentPiece, nextPiece, score, level, totalLinesCleared;
    let gameInterval=null,isGameOver=false,isPaused=false;

    /* ---------- SHAPES (intentionally awkward) ---------- */
    const SHAPES=[
        {blocks:[{x:0,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:1,y:2}],color:'color-1'},
        {blocks:[{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:2,y:1},{x:2,y:2}],color:'color-2'},
        {blocks:[{x:1,y:0},{x:0,y:1},{x:2,y:1},{x:1,y:2}],color:'color-3'},
        {blocks:[{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:1,y:2}],color:'color-4'},
        {blocks:[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:0,y:1},{x:0,y:2},{x:1,y:2},{x:2,y:2}],color:'color-5'},
        {blocks:[{x:0,y:0},{x:2,y:0},{x:0,y:1},{x:2,y:1},{x:0,y:2},{x:1,y:2},{x:2,y:2}],color:'color-6'},
        {blocks:[{x:0,y:0},{x:0,y:1},{x:1,y:1},{x:1,y:2},{x:2,y:2}],color:'color-7'}
    ];

    /* ---------- INITIALISE ---------- */
    function initGame(){
        // Calculate block size based on board width for proper scaling
        BLOCK_SIZE = Math.floor(board.offsetWidth / COLS);
        
        // Adjust board height to be exactly ROWS * BLOCK_SIZE to prevent overflow
        board.style.height = `${ROWS * BLOCK_SIZE}px`;

        board.innerHTML=`<div class="game-over" style="display: none;">
            <div class="game-over-text">0 lines completed!</div> 
            <div class="final-score-message">You were as rubbish as anyone else at this game.</div>
            <button id="restart-button">Play Again</button>
        </div>`;

        gameOverScreen = board.querySelector('.game-over');
        restartButton  = board.querySelector('#restart-button');

        grid  = Array.from({length:ROWS},()=>Array(COLS).fill(0));
        score = 0;
        level = 1;
        totalLinesCleared = 0;
        isGameOver=false;
        isPaused=false;

        scoreDisp.textContent=score;
        levelDisp.textContent=level;
        
        currentPiece = null;
        nextPiece=getRandomShape();
        
        gameOverScreen.style.display='none';
        if(restartButton) restartButton.addEventListener('click', function(e) {
            e.preventDefault();
            startGameProcedure();
        });

        // Initialize audio if needed
        if (!isAudioInitialized) {
            initAudio();
        }
        
        // Start the music
        if (isAudioInitialized && !isMusicPlaying) {
            playMelody(mainTheme, true);
            isMusicPlaying = true;
            if (musicToggle) musicToggle.textContent = "🔊 Music";
        }

        startLoop();
    }

    /* ---------- HELPERS ---------- */
    const getRandomShape=()=>JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random()*SHAPES.length)]));

    function drawBlock(x,y,color,target){
        const d=document.createElement('div');
        d.className=`tetromino ${color}`;
        d.style.cssText=`width:${BLOCK_SIZE}px;height:${BLOCK_SIZE}px;left:${x*BLOCK_SIZE}px;top:${y*BLOCK_SIZE}px`;
        target.appendChild(d); return d;
    }

    function redrawAllBlocks() {
        // Remove all current locked blocks
        const oldBlocks = document.querySelectorAll('.locked-block');
        oldBlocks.forEach(b => b.remove());
        
        // Redraw all blocks based on the grid data
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (grid[y][x]) {
                    const lb = document.createElement('div');
                    lb.className = `locked-block ${grid[y][x]}`;
                    lb.style.cssText = `width:${BLOCK_SIZE}px;height:${BLOCK_SIZE}px;left:${x*BLOCK_SIZE}px;top:${y*BLOCK_SIZE}px`;
                    board.appendChild(lb);
                }
            }
        }
    }

    function drawCurrentPiece(){
        if(!currentPiece) return;
        currentPiece.elements=[];
        const currentShapeBlocks = getShapeForRotation(currentPiece.originalShapeBlocks, currentPiece.rotation);
        currentShapeBlocks.forEach(b=>{
            const x=currentPiece.x+b.x;
            const y=currentPiece.y+b.y;
            if(y>=0) currentPiece.elements.push(drawBlock(x,y,currentPiece.color,board));
        });
    }

    function drawNextPiece(){
        nextPieceDisp.innerHTML='';
        if(!nextPiece) return;
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        nextPiece.blocks.forEach(b=>{minX=Math.min(minX,b.x);minY=Math.min(minY,b.y);maxX=Math.max(maxX,b.x);maxY=Math.max(maxY,b.y);});
        
        const pieceGridWidth  = maxX-minX+1;
        const pieceGridHeight = maxY-minY+1;

        const scaleFactorW = nextPieceDisp.offsetWidth  / (pieceGridWidth + 1); 
        const scaleFactorH = nextPieceDisp.offsetHeight / (pieceGridHeight + 1); 
        const bs = Math.floor(Math.min(scaleFactorW, scaleFactorH));

        const totalRenderedPieceWidth  = pieceGridWidth * bs;
        const totalRenderedPieceHeight = pieceGridHeight * bs;

        const offX = Math.round((nextPieceDisp.offsetWidth - totalRenderedPieceWidth) / 2);
        const offY = Math.round((nextPieceDisp.offsetHeight - totalRenderedPieceHeight) / 2);
        
        nextPiece.blocks.forEach(b=>{
            const d=document.createElement('div');
            d.className=`tetromino ${nextPiece.color}`;
            const blockDspX = offX + (b.x - minX) * bs;
            const blockDspY = offY + (b.y - minY) * bs;
            d.style.cssText=`width:${bs}px;height:${bs}px;left:${blockDspX}px;top:${blockDspY}px`;
            nextPieceDisp.appendChild(d);
        });
    }


    function createNewPiece(){
        currentPiece = nextPiece;
        
        let minXBlock = Math.min(...currentPiece.blocks.map(b => b.x));
        let maxXBlock = Math.max(...currentPiece.blocks.map(b => b.x));
        let minYBlock = Math.min(...currentPiece.blocks.map(b => b.y));
        let pieceDefinedWidth = maxXBlock - minXBlock + 1;

        currentPiece.x = Math.floor((COLS - pieceDefinedWidth) / 2) - minXBlock;
        currentPiece.y = 0 - minYBlock;
        currentPiece.rotation = 0;
        currentPiece.originalShapeBlocks = JSON.parse(JSON.stringify(currentPiece.blocks));
        currentPiece.elements = [];

        nextPiece = getRandomShape();
        drawNextPiece();

        if (collides(0, 0, currentPiece.rotation)) {
            gameOver();
            return false;
        }
        drawCurrentPiece();
        return true;
    }

    function getShapeForRotation(originalBlocks, rotationState) {
        const blocksToRotate = JSON.parse(JSON.stringify(originalBlocks));
        if (rotationState === 0) return blocksToRotate;
        if (rotationState === 1) return blocksToRotate.map(b => ({ x: -b.y, y: b.x }));
        if (rotationState === 2) return blocksToRotate.map(b => ({ x: -b.x, y: -b.y }));
        if (rotationState === 3) return blocksToRotate.map(b => ({ x: b.y, y: -b.x }));
        return blocksToRotate;
    }

    function collides(dx, dy, rotationStateToTest) {
        if (!currentPiece || !currentPiece.originalShapeBlocks) return true;
        const rState = (rotationStateToTest !== undefined) ? rotationStateToTest : currentPiece.rotation;
        const testBlocks = getShapeForRotation(currentPiece.originalShapeBlocks, rState);
        return testBlocks.some(b => {
            const x = currentPiece.x + b.x + dx;
            const y = currentPiece.y + b.y + dy;
            // Strict boundary checking - ensure pieces stop exactly at bottom edge
            if (x < 0 || x >= COLS || y >= ROWS) return true;
            // Check for collision with existing blocks
            return y >= 0 && grid[y] && grid[y][x];
        });
    }

    function move(dx,dy){
        if (!currentPiece || isGameOver || isPaused) return false;
        if (!collides(dx, dy, currentPiece.rotation)) {
            if (currentPiece.elements) currentPiece.elements.forEach(e => e.remove());
            currentPiece.x += dx;
            currentPiece.y += dy;
            drawCurrentPiece();
            return true;
        }
        if (dy > 0) {
            lockPiece();
        }
        return false;
    }

    function rotatePiece(){
        if (!currentPiece || isGameOver || isPaused) return;
        const newRotationState = (currentPiece.rotation + 1) % 4;
        if (!collides(0, 0, newRotationState)) {
            if (currentPiece.elements) currentPiece.elements.forEach(e => e.remove());
            currentPiece.rotation = newRotationState;
            drawCurrentPiece();
        } else if (tryKicks(newRotationState)) {
            if (currentPiece.elements) currentPiece.elements.forEach(e => e.remove());
            currentPiece.rotation = newRotationState;
            drawCurrentPiece();
        }
    }

    function tryKicks(targetRotationState){
        if (!currentPiece) return false;
        const kicks=[{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:-2,y:0},{x:2,y:0}, {x:0,y:-2}];
        for(const k of kicks) {
            if(!collides(k.x, k.y, targetRotationState)){
                currentPiece.x += k.x;
                currentPiece.y += k.y;
                return true;
            }
        }
        return false;
    }

    function hardDrop(){
        if(!currentPiece || isGameOver || isPaused) return;
        let linesDropped = 0;
        while(move(0,1)) {
            linesDropped++;
        }
        if (linesDropped > 0) {
           score += linesDropped * 1;
           updateScore();
        }
    }

    function lockPiece(){
        if (!currentPiece) return;
        const currentShapeBlocks = getShapeForRotation(currentPiece.originalShapeBlocks, currentPiece.rotation);
        let pieceLockedSuccessfully = false;
        currentShapeBlocks.forEach(b=>{
            const x=currentPiece.x+b.x;
            const y=currentPiece.y+b.y;
            if(y>=0 && y < ROWS && x >= 0 && x < COLS){
                grid[y][x]=currentPiece.color;
                const lb=document.createElement('div');
                lb.className=`locked-block ${currentPiece.color}`;
                lb.style.cssText=`width:${BLOCK_SIZE}px;height:${BLOCK_SIZE}px;left:${x*BLOCK_SIZE}px;top:${y*BLOCK_SIZE}px`;
                board.appendChild(lb);
                pieceLockedSuccessfully = true;
            }
        });
        if (currentPiece.elements) currentPiece.elements.forEach(e=>e.remove());
        currentPiece = null;
        if (pieceLockedSuccessfully) {
            checkLines();
        }
        if (!createNewPiece()) {
            // Game over handled in createNewPiece/gameOver
        }
        updateScore();
    }

    function checkLines(){
        let linesClearedThisTurn = 0;
        // Process lines from bottom to top
        for(let y=ROWS-1;y>=0;y--){
            if(grid[y].every(cellColor => cellColor !== 0)){
                linesClearedThisTurn++;
                // Create a gap at random position (this is the "impossible" part)
                const gapColumn = Math.floor(Math.random()*COLS);
                grid[y][gapColumn] = 0;
                
                // Handle clearing the line with a gap
                clearLineWithGap(y, gapColumn);
                
                // Play sound effect
                if (isAudioInitialized) {
                    playLineClearEffect();
                }
            }
        }
        if (linesClearedThisTurn > 0) {
            totalLinesCleared += linesClearedThisTurn;
            score += (linesClearedThisTurn * 100) * linesClearedThisTurn;
            updateScore();
        }
    }

    function clearLineWithGap(yline, gapColumn){
        // First, let's update our grid data structure
        // Shift all rows down for the column with the gap
        for (let y = yline; y > 0; y--) {
            grid[y][gapColumn] = grid[y-1][gapColumn];
        }
        grid[0][gapColumn] = 0; // Top row of gap column is now empty
        
        // For all other columns in this row, mark them for removal
        for (let x = 0; x < COLS; x++) {
            if (x !== gapColumn) {
                grid[yline][x] = 0;
            }
        }
        
        // Now update the visual blocks
        const allLockedBlocks = document.querySelectorAll('.locked-block');
        const blocksToRemove = [];
        const blocksToDrop = [];
        
        allLockedBlocks.forEach(b => {
            const blockY = Math.round(parseFloat(b.style.top) / BLOCK_SIZE);
            const blockX = Math.round(parseFloat(b.style.left) / BLOCK_SIZE);
            
            if (blockY === yline) {
                if (blockX === gapColumn) {
                    // This is the gap - don't do anything to this block
                } else {
                    // This block should be removed (part of cleared line)
                    blocksToRemove.push(b);
                    b.style.transition = 'background 0.05s ease-out';
                    b.style.background = '#fff';
                }
            } 
            else if (blockY < yline && blockX === gapColumn) {
                // This block is above the gap column - needs to drop
                blocksToDrop.push(b);
            }
        });
        
        // Flash and remove blocks in the line
        setTimeout(() => {
            blocksToRemove.forEach(b => b.remove());
            
            // Drop blocks above the gap column
            blocksToDrop.forEach(b => {
                const blockY = Math.round(parseFloat(b.style.top) / BLOCK_SIZE);
                const blockX = Math.round(parseFloat(b.style.left) / BLOCK_SIZE);
                
                // Move this block down one row
                const newY = blockY + 1;
                b.style.top = `${newY * BLOCK_SIZE}px`;
            });
            
            // We need to redraw all blocks to ensure they match our grid data structure
            redrawAllBlocks();
        }, 100);
    }

    function updateScore(){
        scoreDisp.textContent = score;
        const newLevel = Math.min(Math.floor(score / 500) + 1, 10);
        if(newLevel > level){
            level = newLevel;
            levelDisp.textContent = level;
            clearInterval(gameInterval);
            const newIntervalTime = Math.max(100, UPDATE_MS - (level - 1) * 90);
            gameInterval = setInterval(dropPiece, newIntervalTime);
        }
    }

    function gameOver(){
        if (isGameOver) return;
        isGameOver=true;
        clearInterval(gameInterval);
        
        // Play game over sound
        if (isAudioInitialized) {
            playGameOverEffect();
            stopMusic();
        }
        
        if (gameOverScreen) {
            const gameOverTextEl = gameOverScreen.querySelector('.game-over-text');
            if (gameOverTextEl) {
                gameOverTextEl.textContent = `${totalLinesCleared} line${totalLinesCleared === 1 ? '' : 's'} completed!`;
            }
            gameOverScreen.style.display='flex';
        }
        if (startButton) startButton.style.display = 'block';
    }

    const dropPiece = () => {
        if (!isPaused && !isGameOver) {
            move(0, 1);
        }
    };

    function startLoop(){
        clearInterval(gameInterval);
        if (!createNewPiece()) {
            return;
        }
        gameInterval=setInterval(dropPiece, UPDATE_MS - (level - 1) * 90);
    }

    /* ---------- INPUT ---------- */
    document.addEventListener('keydown',e=>{
        if (isGameOver) {
            if (e.key === 'Enter' || e.key === ' ') {
                if (document.activeElement === restartButton) {
                    startGameProcedure();
                    e.preventDefault();
                }
            }
            return;
        }
        if(e.key.toLowerCase() === 'p'){
            isPaused = !isPaused;
            return;
        }
        if(isPaused) return;
        let actionTaken = false;
        switch(e.key){
            case'ArrowLeft': move(-1,0); actionTaken = true; break;
            case'ArrowRight': move(1,0); actionTaken = true; break;
            case'ArrowDown': move(0,1); actionTaken = true; break;
            case'ArrowUp': rotatePiece(); actionTaken = true; break;
            case' ': hardDrop(); actionTaken = true; break;
        }
        if(actionTaken) e.preventDefault();
    });

    // Touch controls for mobile
    if (startButton) {
        startButton.addEventListener('click', function(e) {
            e.preventDefault();
            startGameProcedure();
        });
    }

    // Calculate block size
    if (board.offsetWidth > 0) {
        BLOCK_SIZE = Math.floor(board.offsetWidth / COLS);
    }
    
    // Initial setup
    setupTouchControls();
    
    // Prevent iOS bouncing/scrolling
    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('#tetris-board') || 
            e.target.closest('.mobile-controls') || 
            e.target.classList.contains('mobile-btn')) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Handle visibility changes for mobile (pause when switching tabs/apps)
    document.addEventListener('visibilitychange', function() {
        if (document.hidden && !isGameOver) {
            isPaused = true;
        }
    });

    let touchStartX = 0;
    let touchStartY = 0;
    let lastTapTime = 0;
    let touchMoved = false;
    
    // Improved touch controls for better mobile experience
    function setupTouchControls() {
        // Remove old touch event listeners if they exist
        board.removeEventListener('touchstart', handleTouchStart);
        board.removeEventListener('touchmove', handleTouchMove);
        board.removeEventListener('touchend', handleTouchEnd);
        
        // Add new touch event listeners
        board.addEventListener('touchstart', handleTouchStart, { passive: false });
        board.addEventListener('touchmove', handleTouchMove, { passive: false });
        board.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        // Mobile buttons
        const mobileLeftBtn = document.getElementById('mobile-left');
        const mobileRightBtn = document.getElementById('mobile-right');
        const mobileRotateBtn = document.getElementById('mobile-rotate');
        const mobileDownBtn = document.getElementById('mobile-down');
        const mobileDropBtn = document.getElementById('mobile-drop');
        
        // Setup mobile button controls with improved handling for mobile
        if (mobileLeftBtn) {
            ['touchstart', 'mousedown'].forEach(evt => {
                mobileLeftBtn.addEventListener(evt, (e) => {
                    e.preventDefault();
                    if (!isGameOver && !isPaused) move(-1, 0);
                });
            });
        }
        
        if (mobileRightBtn) {
            ['touchstart', 'mousedown'].forEach(evt => {
                mobileRightBtn.addEventListener(evt, (e) => {
                    e.preventDefault();
                    if (!isGameOver && !isPaused) move(1, 0);
                });
            });
        }
        
        if (mobileRotateBtn) {
            ['touchstart', 'mousedown'].forEach(evt => {
                mobileRotateBtn.addEventListener(evt, (e) => {
                    e.preventDefault();
                    if (!isGameOver && !isPaused) rotatePiece();
                });
            });
        }
        
        if (mobileDownBtn) {
            ['touchstart', 'mousedown'].forEach(evt => {
                mobileDownBtn.addEventListener(evt, (e) => {
                    e.preventDefault();
                    if (!isGameOver && !isPaused) move(0, 1);
                });
            });
        }
        
        if (mobileDropBtn) {
            ['touchstart', 'mousedown'].forEach(evt => {
                mobileDropBtn.addEventListener(evt, (e) => {
                    e.preventDefault();
                    if (!isGameOver && !isPaused) hardDrop();
                });
            });
        }
    }
    
    // Handle touch start event
    function handleTouchStart(e) {
        if (isGameOver || isPaused) return;
        
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchMoved = false;
        e.preventDefault();
    }
    
    // Handle touch move event
    function handleTouchMove(e) {
        if (isGameOver || isPaused) return;
        touchMoved = true;
        e.preventDefault();
    }
    
    // Handle touch end event with improved controls
    function handleTouchEnd(e) {
        if (isGameOver || isPaused) return;
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        
        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;
        
        const threshold = 20; // Smaller threshold for better responsiveness
        
        if (!touchMoved || (Math.abs(diffX) < threshold && Math.abs(diffY) < threshold)) {
            // Handle tap (for rotation)
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;
            
            if (tapLength < 300 && tapLength > 0) {
                // Double tap - hard drop
                hardDrop();
            } else {
                // Single tap - rotate
                rotatePiece();
            }
            
            lastTapTime = currentTime;
        } else if (Math.abs(diffX) > Math.abs(diffY)) {
            // Horizontal swipe
            if (Math.abs(diffX) > threshold) {
                if (diffX > 0) {
                    move(1, 0); // Right
                } else {
                    move(-1, 0); // Left
                }
            }
        } else {
            // Vertical swipe
            if (Math.abs(diffY) > threshold) {
                if (diffY > 0) {
                    move(0, 1); // Down
                } else {
                    hardDrop(); // Up swipe for hard drop
                }
            }
        }
        
        e.preventDefault();
    }
    
    /* ---------- BUTTONS ---------- */
    function startGameProcedure() {
        if (startButton) startButton.style.display='none';
        initGame();
        setupTouchControls();
    }
});
</script>
</body>
</html>